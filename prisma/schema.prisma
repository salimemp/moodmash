generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String            @id @default(cuid())
  name          String?
  email         String?           @unique
  emailVerified DateTime?
  image         String?
  password      String?
  bio           String?           @db.Text
  settings      String?           @db.Text
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  
  // MFA fields
  mfaEnabled    Boolean           @default(false)
  mfaSecret     String?
  mfaBackupCodes String[]         @default([])
  
  // WebAuthn fields
  credentials Credential[]

  accounts      Account[]
  sessions      Session[]
  moods         Mood[]
  moodLikes     MoodLike[]
  moodComments  MoodComment[]
  moodMashes    MoodMash[]
  achievements  AchievementUser[]

  // Encryption and E2EE fields
  encryptionKey      EncryptionKey?
  encryptedPrefs     EncryptedPreferences?
  sentMessages       EncryptedMessage[] @relation("SentMessages")
  receivedMessages   EncryptedMessage[] @relation("ReceivedMessages")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Mood {
  id             String         @id @default(cuid())
  userId         String
  gradientColors String[]
  emoji          String?
  text           String?
  isAnonymous    Boolean        @default(false)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  moodComments   MoodComment[]
  moodLikes      MoodLike[]
  moodMashes     MoodMashMood[]
}

model MoodLike {
  id        String   @id @default(cuid())
  moodId    String
  userId    String
  createdAt DateTime @default(now())
  mood      Mood     @relation(fields: [moodId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([moodId, userId])
}

model MoodComment {
  id        String   @id @default(cuid())
  moodId    String
  userId    String
  text      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  mood      Mood     @relation(fields: [moodId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model MoodMash {
  id                   String         @id @default(cuid())
  userId               String
  resultGradientColors String[]
  resultEmoji          String?
  resultText           String?
  createdAt            DateTime       @default(now())
  user                 User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  moods                MoodMashMood[]
}

model MoodMashMood {
  moodMashId String
  moodId     String
  mood       Mood     @relation(fields: [moodId], references: [id], onDelete: Cascade)
  moodMash   MoodMash @relation(fields: [moodMashId], references: [id], onDelete: Cascade)

  @@id([moodMashId, moodId])
}

model Achievement {
  id          String            @id @default(cuid())
  name        String            @unique
  description String
  icon        String
  createdAt   DateTime          @default(now())
  users       AchievementUser[]
}

model AchievementUser {
  achievementId String
  userId        String
  unlockedAt    DateTime    @default(now())
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([achievementId, userId])
}

// WebAuthn credentials model
model Credential {
  id            String   @id @default(cuid())
  userId        String
  externalId    String   @unique // The credential ID from the client
  publicKey     String
  counter       Int      @default(0)
  deviceType    String?  // platform, cross-platform
  backupState   Boolean? // Whether the credential is backed up
  transports    String[] @default([])
  friendlyName  String?
  createdAt     DateTime @default(now())
  lastUsed      DateTime @default(now())

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Encryption key for a user
model EncryptionKey {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  publicKey     String   // Base64 encoded public key
  salt          String   // Base64 encoded salt for key derivation
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// Encrypted user preferences
model EncryptedPreferences {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ciphertext    String   @db.Text // Base64 encoded encrypted data
  nonce         String   // Base64 encoded nonce
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// Encrypted messages between users
model EncryptedMessage {
  id              String    @id @default(cuid())
  senderId        String
  sender          User      @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  recipientId     String
  recipient       User      @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)
  ciphertext      String    @db.Text // Base64 encoded encrypted message
  nonce           String    // Base64 encoded nonce
  senderPublicKey String    // Base64 encoded sender's public key
  timestamp       DateTime  @default(now())
  read            Boolean   @default(false)
  metadata        String?   @db.Text // Optional JSON metadata (e.g., message type)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}
